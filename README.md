CUDA Stream Compaction
======================

**University of Pennsylvania, CIS 565: GPU Programming and Architecture, Project 2**

* Nadine Adnane
  * [LinkedIn](https://www.linkedin.com/in/nadnane/)
* Tested on my personal laptop (ASUS ROG Zephyrus M16):
* **OS:** Windows 11
* **Processor:** 12th Gen Intel(R) Core(TM) i9-12900H, 2500 Mhz, 14 Core(s), 20 Logical Processor(s) 
* **GPU:** NVIDIA GeForce RTX 3070 Ti Laptop GPU

Note: I used a late day on this assignment. I also need a few more hours to finish up my analysis.

### Introduction

In this project, I set out to implement a few different versions of the Scan (Prefix Sum) algorithm and GPU stream compaction in CUDA. I first implemented the algorithms on the CPU as a basis for comparison and to reinforce my understanding of the algorithm. Then, I implemented the "naive" and "work-efficient" versions of the algorithm on the GPU using CUDA. Finally, I utilized some of my earlier implementations to implement GPU stream compaction. Through this project, I analyze the trade-offs between CPU and GPU performance and explore the benefits of parallel programming.

### Features

1. **CPU Scan & Stream Compaction**
   - **CPU Scan:** Implemented a straightforward exclusive prefix sum using a for loop for sequential processing.
   - **Compaction Without Scan:** A basic method that filters out zero values without employing a scan operation.
   - **Compaction With Scan:** An optimized approach that leverages the scan algorithm to enhance the efficiency of the compaction process.

2. **Naive GPU Scan**
   - Developed a naive GPU scan algorithm following the method outlined in *GPU Gems 3*, Section 39.2.1. This implementation utilizes global memory and alternates between input/output arrays through multiple kernel invocations.

3. **Work-Efficient GPU Scan & Stream Compaction**
   - **Work-Efficient Scan:** Implemented an optimized scan using a tree-based approach, as described in *GPU Gems 3*, Section 39.2.2, for better performance.
   - **Stream Compaction with Scan:** Built upon the work-efficient scan by first mapping the input to a boolean array, scanning it, and then scattering the elements that satisfy the condition to achieve compaction.
   - Efficiently handles arrays that are not sized to a power of two.

4. **Thrust Library Integration**
   - Integrated the Thrust libraryâ€™s `exclusive_scan` function to perform stream compaction utilizing the GPU-accelerated primitives offered by Thrust.

## Performance Analysis

# Block Size Optimization
<img src="images/graph1.png" width="900">

# Scan Implementation Comparison
<img src="images/graph2.png" width="900">

# Stream Compaction Implementation Comparison
<img src="images/graph3.png" width="900">



# Test Program Output

The following test output was generated by running the Scan and Stream compaction algorithms on:
- an array of size 2^21
- an array of size 2^21 - 3

with a block size of 128.

```****************
** SCAN TESTS **
****************
    [  47   4  13  41  40  12  10  35  21  19  24  19   8 ...  46   0 ]
==== cpu scan, power-of-two ====
   elapsed time: 6.6257ms    (std::chrono Measured)
    [   0  47  51  64 105 145 157 167 202 223 242 266 285 ... 51377593 51377639 ]
==== cpu scan, non-power-of-two ====
   elapsed time: 6.5007ms    (std::chrono Measured)
    [   0  47  51  64 105 145 157 167 202 223 242 266 285 ... 51377490 51377518 ]
    passed
==== naive scan, power-of-two ====
   elapsed time: 1.49398ms    (CUDA Measured)
    passed
==== naive scan, non-power-of-two ====
   elapsed time: 1.31354ms    (CUDA Measured)
    passed
==== work-efficient scan, power-of-two ====
   elapsed time: 1.48496ms    (CUDA Measured)
    passed
==== work-efficient scan, non-power-of-two ====
   elapsed time: 1.13254ms    (CUDA Measured)
    passed
==== thrust scan, power-of-two ====
   elapsed time: 0.857024ms    (CUDA Measured)
    passed
==== thrust scan, non-power-of-two ====
   elapsed time: 0.697344ms    (CUDA Measured)
    passed

*****************************
** STREAM COMPACTION TESTS **
*****************************
    [   2   1   3   2   1   2   1   2   3   1   0   3   1 ...   1   0 ]
==== cpu compact without scan, power-of-two ====
   elapsed time: 9.0749ms    (std::chrono Measured)
    [   2   1   3   2   1   2   1   2   3   1   3   1   3 ...   3   1 ]
    passed
==== cpu compact without scan, non-power-of-two ====
   elapsed time: 8.3302ms    (std::chrono Measured)
    [   2   1   3   2   1   2   1   2   3   1   3   1   3 ...   3   3 ]
    passed
==== cpu compact with scan ====
   elapsed time: 12.1135ms    (std::chrono Measured)
    [   2   1   3   2   1   2   1   2   3   1   3   1   3 ...   3   1 ]
    passed
==== work-efficient compact, power-of-two ====
   elapsed time: 1.50966ms    (CUDA Measured)
    passed
==== work-efficient compact, non-power-of-two ====
   elapsed time: 1.41312ms    (CUDA Measured)
    passed```